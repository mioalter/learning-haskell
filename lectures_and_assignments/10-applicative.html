<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0062)http://www.seas.upenn.edu/~cis194/lectures/10-applicative.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>10-applicative</title>

  <script type="text/javascript" src="./10-applicative_files/MathJax.js"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Hover_Arrow {position: absolute; width: 15px; height: 11px; cursor: pointer}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; color: #666666}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_Menu_Close {position: absolute; width: 31px; height: 31px; top: -15px; left: -15px}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style>
  <link href="./10-applicative_files/style.css" rel="stylesheet" type="text/css">
</head>
<body class=" hasGoogleVoiceExt"><div id="MathJax_Message" style="display: none;"></div>

  <div id="canvas">
    <div id="nav"><p><strong>CIS 194</strong>: <a href="http://www.seas.upenn.edu/~cis194/">Home</a> | <a href="http://www.seas.upenn.edu/~cis194/lectures.html">Lectures &amp; Assignments</a> | <a href="http://www.seas.upenn.edu/~cis194/policies.html">Policies</a> | <a href="http://www.seas.upenn.edu/~cis194/resources.html">Resources</a> | <a href="http://www.seas.upenn.edu/~cis194/final.html">Final Project</a></p></div>

    <div id="content">
      
      <p><!-- CLASS

> {-# LANGUAGE GeneralizedNewtypeDeriving, NoMonomorphismRestriction #-}

--></p>
<h1 id="applicative-functors-part-i">Applicative functors, Part I</h1>
<p>CIS 194 Week 10<br>25 March 2012</p>
<p>Suggested reading:</p>
<ul>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors">Applicative Functors</a> from Learn You a Haskell</li>
<li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia">The Typeclassopedia</a></li>
</ul>
<h2 id="motivation">Motivation</h2>
<p>Consider the following <code>Employee</code> type:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Employee</span> <span class="fu">=</span> <span class="dt">Employee</span> {<span class="ot"> name    ::</span> <span class="dt">Name</span>
                         ,<span class="ot"> phone   ::</span> <span class="dt">String</span> }
                <span class="kw">deriving</span> <span class="kw">Show</span></code></pre>
<p>Of course, the <code>Employee</code> constructor has type</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Employee</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Employee</span></code></pre>
<p>That is, if we have a <code>Name</code> and a <code>String</code>, we can apply the <code>Employee</code> constructor to build an <code>Employee</code> object.</p>
<p>Suppose, however, that we don’t have a <code>Name</code> and a <code>String</code>; what we actually have is a <code>Maybe Name</code> and a <code>Maybe String</code>. Perhaps they came from parsing some file full of errors, or from a form where some of the fields might have been left blank, or something of that sort. We can’t necessarily make an <code>Employee</code>. But surely we can make a <code>Maybe Employee</code>. That is, we’d like to take our <code>(Name -&gt; String -&gt; Employee)</code> function and turn it into a <code>(Maybe Name -&gt; Maybe String -&gt; Maybe Employee)</code> function. Can we write something with this type?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Employee</span>) <span class="ot">-&gt;</span>
(<span class="dt">Maybe</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Employee</span>)</code></pre>
<p>Sure we can, and I am fully confident that you could write it in your sleep by now. We can imagine how it would work: if either the name or string is <code>Nothing</code>, we get <code>Nothing</code> out; if both are <code>Just</code>, we get out an <code>Employee</code> built using the <code>Employee</code> constructor (wrapped in <code>Just</code>). But let’s keep going…</p>
<p>Consider this: now instead of a <code>Name</code> and a <code>String</code> we have a <code>[Name]</code> and a <code>[String]</code>. Maybe we can get an <code>[Employee]</code> out of this? Now we want</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Employee</span>) <span class="ot">-&gt;</span>
([<span class="dt">Name</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">Employee</span>])</code></pre>
<p>We can imagine two different ways for this to work: we could match up corresponding <code>Name</code>s and <code>String</code>s to form <code>Employee</code>s; or we could pair up the <code>Name</code>s and <code>String</code>s in all possible ways.</p>
<p>Or how about this: we have an <code>(e -&gt; Name)</code> and <code>(e -&gt; String)</code> for some type <code>e</code>. For example, perhaps <code>e</code> is some huge data structure, and we have functions telling us how to extract a <code>Name</code> and a <code>String</code> from it. Can we make it into an <code>(e -&gt; Employee)</code>, that is, a recipe for extracting an <code>Employee</code> from the same structure?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Employee</span>) <span class="ot">-&gt;</span>
((e <span class="ot">-&gt;</span> <span class="dt">Name</span>) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Employee</span>))</code></pre>
<p>No problem, and this time there’s really only one way to write this function.</p>
<h2 id="generalizing">Generalizing</h2>
<p>Now that we’ve seen the usefulness of this sort of pattern, let’s generalize a bit. The type of the function we want really looks something like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c)</code></pre>
<p>Hmm, this looks familiar… it’s quite similar to the type of <code>fmap</code>!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</code></pre>
<p>The only difference is an extra argument; we might call our desired function <code>fmap2</code>, since it takes a function of two arguments. Perhaps we can write <code>fmap2</code> in terms of <code>fmap</code>, so we just need a <code>Functor</code> constraint on <code>f</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fmap2 ::</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c)
fmap2 h fa fb <span class="fu">=</span> <span class="fu">undefined</span></code></pre>
<p>Try hard as we might, however, <code>Functor</code> does not quite give us enough to implement <code>fmap2</code>. What goes wrong? We have</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">h  ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
<span class="ot">fa ::</span> f a
<span class="ot">fb ::</span> f b</code></pre>
<p>Note that we can also write the type of <code>h</code> as <code>a -&gt; (b -&gt; c)</code>. So, we have a function that takes an <code>a</code>, and we have a value of type <code>f a</code>… the only thing we can do is use <code>fmap</code> to lift the function over the <code>f</code>, giving us a result of type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">h         ::</span> a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)
<span class="fu">fmap</span><span class="ot"> h    ::</span> f a <span class="ot">-&gt;</span> f (b <span class="ot">-&gt;</span> c)
<span class="fu">fmap</span> h<span class="ot"> fa ::</span> f (b <span class="ot">-&gt;</span> c)</code></pre>
<p>OK, so now we have something of type <code>f (b -&gt; c)</code> and something of type <code>f b</code>… and here’s where we are stuck! <code>fmap</code> does not help any more. It gives us a way to apply functions to values inside a <code>Functor</code> context, but what we need now is to apply a functions <em>which are themselves in a <code>Functor</code> context</em> to values in a <code>Functor</code> context.</p>
<h2 id="applicative">Applicative</h2>
<p>Functors for which this sort of “contextual application” is possible are called <em>applicative</em>, and the <code>Applicative</code> class (defined in <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html"><code>Control.Applicative</code></a>) captures this pattern.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="kw">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>The <code>(&lt;*&gt;)</code> operator (often pronounced “ap”, short for “apply”) encapsulates exactly this principle of “contextual application”. Note also that the <code>Applicative</code> class requires its instances to be instances of <code>Functor</code> as well, so we can always use <code>fmap</code> with instances of <code>Applicative</code>. Finally, note that <code>Applicative</code> also has another method, <code>pure</code>, which lets us inject a value of type <code>a</code> into a container. For now, it is interesting to note that <code>fmap0</code> would be another reasonable name for <code>pure</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pure  ::</span> a             <span class="ot">-&gt;</span> f a
<span class="fu">fmap</span><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b)      <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">fmap2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</code></pre>
<p>Now that we have <code>(&lt;*&gt;)</code>, we can implement <code>fmap2</code>, which in the standard library is actually called <code>liftA2</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">liftA2 ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
liftA2 h fa fb <span class="fu">=</span> (h <span class="ot">`fmap`</span> fa) <span class="fu">&lt;*&gt;</span> fb</code></pre>
<p>In fact, this pattern is so common that <code>Control.Applicative</code> defines <code>(&lt;$&gt;)</code> as a synonym for <code>fmap</code>,</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(&lt;$&gt;) ::</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> <span class="fu">fmap</span></code></pre>
<p>so that we can write</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">liftA2 h fa fb <span class="fu">=</span> h <span class="fu">&lt;$&gt;</span> fa <span class="fu">&lt;*&gt;</span> fb</code></pre>
<p>What about <code>liftA3</code>?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">liftA3 ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d
liftA3 h fa fb fc <span class="fu">=</span> ((h <span class="fu">&lt;$&gt;</span> fa) <span class="fu">&lt;*&gt;</span> fb) <span class="fu">&lt;*&gt;</span> fc</code></pre>
<p>(Note that the precedence and associativity of <code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code> are actually defined in such a way that all the parentheses above are unnecessary.)</p>
<p>Nifty! Unlike the jump from <code>fmap</code> to <code>liftA2</code> (which required generalizing from <code>Functor</code> to <code>Applicative</code>), going from <code>liftA2</code> to <code>liftA3</code> (and from there to <code>liftA4</code>, …) requires no extra power—<code>Applicative</code> is enough.</p>
<p>Actually, when we have all the arguments like this we usually don’t bother calling <code>liftA2</code>, <code>liftA3</code>, and so on, but just use the <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z &lt;*&gt; ...</code> pattern directly. (<code>liftA2</code> and friends do come in handly for partial application, however.)</p>
<p>But what about <code>pure</code>? <code>pure</code> is for situations where we want to apply some function to arguments in the context of some functor <code>f</code>, but one or more of the arguments is <em>not</em> in <code>f</code>—those arguments are “pure”, so to speak. We can use <code>pure</code> to lift them up into <code>f</code> first before applying. Like so:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">liftX ::</span> <span class="kw">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d
liftX h fa b fc <span class="fu">=</span> h <span class="fu">&lt;$&gt;</span> fa <span class="fu">&lt;*&gt;</span> pure b <span class="fu">&lt;*&gt;</span> fc</code></pre>
<h2 id="applicative-laws">Applicative laws</h2>
<p>There is only one really “interesting” law for <code>Applicative</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="ot">`fmap`</span> x <span class="fu">===</span> pure f <span class="fu">&lt;*&gt;</span> x</code></pre>
<p>Mapping a function <code>f</code> over a container <code>x</code> ought to give the same results as first injecting the function into the container, and then applying it to <code>x</code> with <code>(&lt;*&gt;)</code>.</p>
<p>There are other laws, but they are not as instructive; you can read about them on your own if you really want.</p>
<h2 id="applicative-examples">Applicative examples</h2>
<p><strong>Maybe</strong></p>
<p>Let’s try writing some instances of <code>Applicative</code>, starting with <code>Maybe</code>. <code>pure</code> works by injecting a value into a <code>Just</code> wrapper; <code>(&lt;*&gt;)</code> is function application with possible failure. The result is <code>Nothing</code> if either the function or its argument are.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  pure              <span class="fu">=</span> <span class="kw">Just</span>
  <span class="kw">Nothing</span> <span class="fu">&lt;*&gt;</span> _     <span class="fu">=</span> <span class="kw">Nothing</span>
  _ <span class="fu">&lt;*&gt;</span> <span class="kw">Nothing</span>     <span class="fu">=</span> <span class="kw">Nothing</span>
  <span class="kw">Just</span> f <span class="fu">&lt;*&gt;</span> <span class="kw">Just</span> x <span class="fu">=</span> <span class="kw">Just</span> (f x)</code></pre>
<p>Let’s see an example:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">m_name1,<span class="ot"> m_name2 ::</span> <span class="dt">Maybe</span> <span class="dt">Name</span>
m_name1 <span class="fu">=</span> <span class="kw">Nothing</span>
m_name2 <span class="fu">=</span> <span class="kw">Just</span> <span class="st">"Brent"</span>

m_phone1,<span class="ot"> m_phone2 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
m_phone1 <span class="fu">=</span> <span class="kw">Nothing</span>
m_phone2 <span class="fu">=</span> <span class="kw">Just</span> <span class="st">"555-1234"</span>

ex01 <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> m_name1 <span class="fu">&lt;*&gt;</span> m_phone1
ex02 <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> m_name1 <span class="fu">&lt;*&gt;</span> m_phone2
ex03 <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> m_name2 <span class="fu">&lt;*&gt;</span> m_phone1
ex04 <span class="fu">=</span> <span class="dt">Employee</span> <span class="fu">&lt;$&gt;</span> m_name2 <span class="fu">&lt;*&gt;</span> m_phone2</code></pre>
<p><!--

Local Variables:
mode:markdown
compile-command:"mk pre"
End:

--></p>
<hr>
<p><code>Generated 2013-04-04 15:15:39.515041</code></p>

    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      and <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>.
      </font></center><font size="-2">
    </font></div><font size="-2">
  </font></div><font size="-2">



</font></body></html>